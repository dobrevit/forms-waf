{{- if .Values.haproxy.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "forms-waf.fullname" . }}-haproxy-config
  labels:
    {{- include "forms-waf.haproxy.labels" . | nindent 4 }}
data:
  haproxy.cfg: |
    #---------------------------------------------------------------------
    # Forms WAF - HAProxy Configuration
    # Global abuse protection with stick-table synchronization
    #
    # Architecture: Chained frontends to support 4 stick-tables with 3 counters
    #   ft_waf (sc0: hash, sc1: ip rate, sc2: ip spam) -> bk_fingerprint_check
    #   ft_fingerprint (sc0: fingerprint) -> bk_application
    #---------------------------------------------------------------------

    global
        log stdout format raw local0 info
        maxconn 4096
        stats socket /var/run/haproxy.sock mode 600 level admin expose-fd listeners
        stats timeout 30s
        {{- if .Values.haproxy.tls.enabled }}
        # SSL settings for internal TLS communication
        ssl-default-bind-ciphers ECDHE+AESGCM:DHE+AESGCM
        ssl-default-bind-options no-sslv3 no-tlsv10 no-tlsv11 no-tls-tickets
        ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
        tune.ssl.default-dh-param 2048
        {{- end }}

    defaults
        log     global
        mode    http
        option  httplog
        option  dontlognull
        option  http-server-close
        option  forwardfor except 127.0.0.0/8
        timeout connect 5s
        timeout client  30s
        timeout server  30s
        timeout http-request 10s

        #log-format "%ci:%cp [%tr] %ft %b/%s %TR/%Tw/%Tc/%Tr/%Ta %ST %B %CC %CS %tsc %ac/%fc/%bc/%sc/%rc %sq/%bq %hr %hs %{+Q}r form_hash=%[req.hdr(X-Form-Hash)] spam_score=%[req.hdr(X-Spam-Score)]"

    peers haproxy_peers
        {{- range $i := until (int .Values.haproxy.replicaCount) }}
        peer {{ include "forms-waf.fullname" $ }}-haproxy-{{ $i }} {{ include "forms-waf.fullname" $ }}-haproxy-{{ $i }}.{{ include "forms-waf.haproxy.headlessServiceName" $ }}:{{ $.Values.haproxy.service.peerPort }}
        {{- end }}

    #---------------------------------------------------------------------
    # Frontend Stage 1 - Main WAF checks (hash, IP rate, IP spam score)
    # Uses sc0, sc1, sc2 then forwards to fingerprint check
    #---------------------------------------------------------------------
    frontend ft_waf
        bind *:8080
        {{- if .Values.haproxy.tls.enabled }}
        bind *:8443 ssl crt /etc/haproxy/ssl/haproxy.pem alpn h2,http/1.1
        {{- end }}

        # ACL definitions for WAF headers
        acl has_form_hash req.hdr(X-Form-Hash) -m found
        acl has_spam_score req.hdr(X-Spam-Score) -m found
        acl has_client_ip req.hdr(X-Client-IP) -m found

        # WAF mode check - only block when in blocking or strict mode
        # In monitoring/passthrough mode, HAProxy should track but not block
        acl waf_should_block req.hdr(X-WAF-Mode) -m str blocking strict

        # Debug mode ACL - used to include headers in error responses
        acl waf_debug_on req.hdr(X-WAF-Debug) -m str on

        # Already blocked by OpenResty
        acl blocked_by_openresty req.hdr(X-Blocked) -m str true

        #-----------------------------------------------------------------
        # Rate limiting ACL (must be defined before tracking)
        #-----------------------------------------------------------------

        # Check if rate limiting is enabled via OpenResty header
        acl rate_limit_enabled req.hdr(X-WAF-Rate-Limit) -m str on

        #-----------------------------------------------------------------
        # Stick-table tracking (Stage 1: hash, IP rate, IP spam)
        # MUST happen before blocking rules so counters are available for debug
        #-----------------------------------------------------------------

        # Track form hash submissions globally (always, for duplicate detection)
        http-request track-sc0 req.hdr(X-Form-Hash) table st_form_hashes if has_form_hash

        # Track client IP submissions (only when rate limiting is enabled for this request)
        http-request track-sc1 req.hdr(X-Client-IP) table st_client_ips if has_client_ip rate_limit_enabled

        # Track spam scores per IP (always, for abuse tracking)
        http-request track-sc2 req.hdr(X-Client-IP) table st_spam_scores if has_client_ip

        #-----------------------------------------------------------------
        # Store debug values BEFORE blocking rules
        # This ensures values are captured even for blocked requests
        #-----------------------------------------------------------------
        http-request set-var(txn.waf_debug) req.hdr(X-WAF-Debug)
        http-request set-var(txn.hash_count) sc0_get_gpc0(st_form_hashes) if has_form_hash
        http-request set-var(txn.ip_rate) sc1_http_req_rate(st_client_ips) if has_client_ip
        http-request set-var(txn.ip_spam_total) sc2_get_gpc0(st_spam_scores) if has_client_ip
        http-request set-var(txn.hash_unique_ips) sc0_get_gpc1(st_form_hashes) if has_form_hash
        http-request set-var(txn.hash_rate) sc0_gpc0_rate(st_form_hashes) if has_form_hash
        http-request set-var(txn.ip_conn_cnt) sc1_conn_cnt(st_client_ips) if has_client_ip

        #-----------------------------------------------------------------
        # Stick-table based blocking ACLs (Stage 1)
        #-----------------------------------------------------------------

        # Get rate limit value from header (default to 30 if not set)
        http-request set-var(txn.rate_limit) req.hdr(X-WAF-Rate-Limit-Value),regsub(^$,30)

        # Dynamic thresholds from OpenResty (with defaults)
        http-request set-var(txn.spam_threshold) req.hdr(X-WAF-Spam-Threshold),regsub(^$,80)
        http-request set-var(txn.hash_rate_threshold) req.hdr(X-WAF-Hash-Rate-Threshold),regsub(^$,10)
        http-request set-var(txn.ip_spam_threshold) req.hdr(X-WAF-IP-Spam-Threshold),regsub(^$,500)

        # High spam score (blocked at HAProxy level) - uses dynamic threshold
        acl spam_score_high req.hdr(X-Spam-Score),sub(txn.spam_threshold) ge 0

        # Form hash seen too many times (global duplicate detection) - uses dynamic threshold
        acl hash_flood sc0_gpc0_rate(st_form_hashes),sub(txn.hash_rate_threshold) ge 0

        # Form hash has been manually flagged
        acl hash_flagged sc0_get_gpc1(st_form_hashes) gt 0

        # Client IP submission rate too high (respects per-request rate limit)
        acl ip_rate_exceeded sc1_http_req_rate(st_client_ips),sub(txn.rate_limit) ge 0

        # Client IP has accumulated too many spam submissions - uses dynamic threshold
        acl ip_spam_score sc2_get_gpc0(st_spam_scores),sub(txn.ip_spam_threshold) ge 0

        #-----------------------------------------------------------------
        # Blocking rules with debug headers (http-request return)
        # When debug is ON, use return to include headers in error response
        # When debug is OFF, use deny for simpler response
        #-----------------------------------------------------------------

        # Blocked by OpenResty - with debug headers
        http-request return status 403 content-type "text/plain" string "Blocked by WAF" hdr X-WAF-Block-Rule-Stage1 "blocked_by_openresty" if blocked_by_openresty waf_should_block waf_debug_on
        http-request deny deny_status 403 if blocked_by_openresty waf_should_block

        # High spam score - with debug headers
        http-request return status 403 content-type "text/plain" string "Blocked by WAF" hdr X-WAF-Block-Rule-Stage1 "spam_score_high" hdr X-WAF-Spam-Score %[req.hdr(X-Spam-Score)] if spam_score_high waf_should_block waf_debug_on
        http-request deny deny_status 403 if spam_score_high waf_should_block

        # Hash flood - with debug headers
        http-request return status 429 content-type "text/plain" string "Rate limited" hdr X-WAF-Block-Rule-Stage1 "hash_flood" hdr X-WAF-Hash-Rate %[var(txn.hash_rate)] hdr X-WAF-Hash-Count %[var(txn.hash_count)] if hash_flood rate_limit_enabled waf_should_block waf_debug_on
        http-request deny deny_status 429 if hash_flood rate_limit_enabled waf_should_block

        # Hash flagged - with debug headers
        http-request return status 403 content-type "text/plain" string "Blocked by WAF" hdr X-WAF-Block-Rule-Stage1 "hash_flagged" hdr X-WAF-Hash-Count %[var(txn.hash_count)] if hash_flagged waf_should_block waf_debug_on
        http-request deny deny_status 403 if hash_flagged waf_should_block

        # IP rate exceeded - with debug headers
        http-request return status 429 content-type "text/plain" string "Rate limited" hdr X-WAF-Block-Rule-Stage1 "ip_rate_exceeded" hdr X-WAF-IP-Rate %[var(txn.ip_rate)] hdr X-WAF-IP-Conn-Count %[var(txn.ip_conn_cnt)] if ip_rate_exceeded rate_limit_enabled waf_should_block waf_debug_on
        http-request deny deny_status 429 if ip_rate_exceeded rate_limit_enabled waf_should_block

        # IP spam score - with debug headers
        http-request return status 403 content-type "text/plain" string "Blocked by WAF" hdr X-WAF-Block-Rule-Stage1 "ip_spam_score" hdr X-WAF-IP-Spam-Total %[var(txn.ip_spam_total)] if ip_spam_score rate_limit_enabled waf_should_block waf_debug_on
        http-request deny deny_status 403 if ip_spam_score rate_limit_enabled waf_should_block

        #-----------------------------------------------------------------
        # Update counters
        #-----------------------------------------------------------------

        # Increment form hash counter
        http-request sc-inc-gpc0(0) if has_form_hash

        # Add spam score to IP's cumulative score
        http-request set-var(txn.spam_score) req.hdr(X-Spam-Score) if has_spam_score
        # Note: GPC increment is by 1, for weighted scoring we'd use a map

        #-----------------------------------------------------------------
        # Track blocking decision for stage 1 (for non-blocked requests)
        #-----------------------------------------------------------------
        http-request set-var(txn.block_rule) str(none)
        http-request set-var(txn.block_rule) str(blocked_by_openresty) if blocked_by_openresty
        http-request set-var(txn.block_rule) str(spam_score_high) if spam_score_high
        http-request set-var(txn.block_rule) str(hash_flood) if hash_flood
        http-request set-var(txn.block_rule) str(hash_flagged) if hash_flagged
        http-request set-var(txn.block_rule) str(ip_rate_exceeded) if ip_rate_exceeded
        http-request set-var(txn.block_rule) str(ip_spam_score) if ip_spam_score

        #-----------------------------------------------------------------
        # Add response headers for stage 1 debug (only when X-WAF-Debug: on)
        # NOTE: These only apply for non-blocked requests (return handles blocked)
        #-----------------------------------------------------------------
        http-response set-header X-WAF-Hash-Count %[var(txn.hash_count)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-IP-Rate %[var(txn.ip_rate)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-IP-Spam-Total %[var(txn.ip_spam_total)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Hash-Rate %[var(txn.hash_rate)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Hash-Unique-IPs %[var(txn.hash_unique_ips)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-IP-Conn-Count %[var(txn.ip_conn_cnt)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Block-Rule-Stage1 %[var(txn.block_rule)] if { var(txn.waf_debug) -m str "on" }
        # Dynamic threshold debug headers
        http-response set-header X-WAF-Threshold-Spam %[var(txn.spam_threshold)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Threshold-Hash-Rate %[var(txn.hash_rate_threshold)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Threshold-IP-Spam %[var(txn.ip_spam_threshold)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Threshold-Rate-Limit %[var(txn.rate_limit)] if { var(txn.waf_debug) -m str "on" }

        # Forward to fingerprint check stage
        default_backend bk_fingerprint_check

    #---------------------------------------------------------------------
    # Backend - bridges to fingerprint frontend (internal)
    #---------------------------------------------------------------------
    backend bk_fingerprint_check
        server fingerprint_check abns@ft_fingerprint send-proxy

    #---------------------------------------------------------------------
    # Frontend Stage 2 - Fingerprint tracking (uses sc0)
    # Receives traffic from ft_waf via internal proxy
    #---------------------------------------------------------------------
    frontend ft_fingerprint
        bind abns@ft_fingerprint accept-proxy

        # ACL for fingerprint header
        acl has_fingerprint req.hdr(X-Submission-Fingerprint) -m found
        acl waf_should_block req.hdr(X-WAF-Mode) -m str blocking strict

        # Debug mode ACL - used to include headers in error responses
        acl waf_debug_on req.hdr(X-WAF-Debug) -m str on

        #-----------------------------------------------------------------
        # Stick-table tracking (Stage 2: fingerprint only)
        #-----------------------------------------------------------------

        # Track submission fingerprints (for coordinated attack detection)
        http-request track-sc0 req.hdr(X-Submission-Fingerprint) table st_fingerprints if has_fingerprint

        #-----------------------------------------------------------------
        # Store debug values BEFORE blocking rules
        # NOTE: Must re-read X-WAF-Debug header (new transaction scope)
        #-----------------------------------------------------------------
        http-request set-var(txn.waf_debug) req.hdr(X-WAF-Debug)
        http-request set-var(txn.fingerprint_rate) sc0_http_req_rate(st_fingerprints) if has_fingerprint
        http-request set-var(txn.fingerprint_cnt) sc0_http_req_cnt(st_fingerprints) if has_fingerprint

        # Dynamic fingerprint threshold from OpenResty (with default)
        http-request set-var(txn.fingerprint_threshold) req.hdr(X-WAF-Fingerprint-Threshold),regsub(^$,20)
        # Store fingerprint profile for debug response headers
        http-request set-var(txn.fingerprint_profile) req.hdr(X-Fingerprint-Profile)

        #-----------------------------------------------------------------
        # Fingerprint-based blocking
        #-----------------------------------------------------------------

        # Block if submission fingerprint seen too many times (coordinated attack)
        # High rate from same fingerprint = bot network or scripted attack - uses dynamic threshold
        acl fingerprint_flood sc0_http_req_rate(st_fingerprints),sub(txn.fingerprint_threshold) ge 0

        # Fingerprint flood - with debug headers
        http-request return status 429 content-type "text/plain" string "Rate limited" hdr X-WAF-Block-Rule-Stage2 "fingerprint_flood" hdr X-WAF-Fingerprint-Rate %[var(txn.fingerprint_rate)] hdr X-WAF-Fingerprint-Count %[var(txn.fingerprint_cnt)] if fingerprint_flood has_fingerprint waf_should_block waf_debug_on
        http-request deny deny_status 429 if fingerprint_flood has_fingerprint waf_should_block

        #-----------------------------------------------------------------
        # Track blocking decision for stage 2 (for non-blocked requests)
        #-----------------------------------------------------------------
        http-request set-var(txn.block_rule) str(none)
        http-request set-var(txn.block_rule) str(fingerprint_flood) if fingerprint_flood

        #-----------------------------------------------------------------
        # Add response headers for stage 2 debug (only when X-WAF-Debug: on)
        # NOTE: These only apply for non-blocked requests (return handles blocked)
        #-----------------------------------------------------------------
        http-response set-header X-WAF-Fingerprint-Rate %[var(txn.fingerprint_rate)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Fingerprint-Count %[var(txn.fingerprint_cnt)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Block-Rule-Stage2 %[var(txn.block_rule)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Threshold-Fingerprint %[var(txn.fingerprint_threshold)] if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Fingerprint-Profile %[var(txn.fingerprint_profile)] if { var(txn.waf_debug) -m str "on" }

        # Timing info from backend
        http-response set-header X-WAF-Queue-Time %Tw if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Backend-Time %Tr if { var(txn.waf_debug) -m str "on" }
        http-response set-header X-WAF-Total-Time %Ta if { var(txn.waf_debug) -m str "on" }

        default_backend bk_application

    #---------------------------------------------------------------------
    # Stick Tables
    #---------------------------------------------------------------------

    # Form hash tracking - detects duplicate/spam content globally
    backend st_form_hashes
        stick-table type string len 64 size 100k expire 1h peers haproxy_peers store gpc0,gpc0_rate(60s),gpc1,conn_cnt

    # Client IP tracking - rate limiting per IP
    backend st_client_ips
        stick-table type string len 45 size 50k expire 1h peers haproxy_peers store http_req_rate(60s),http_req_cnt,gpc0,conn_cnt

    # Spam score accumulation per IP
    backend st_spam_scores
        stick-table type string len 45 size 50k expire 24h peers haproxy_peers store gpc0,gpc1

    # Submission fingerprint tracking - detects coordinated spam campaigns
    # Fingerprint = hash of form structure + user-agent + accept-language
    backend st_fingerprints
        stick-table type string len 16 size 100k expire 1h peers haproxy_peers store http_req_rate(60s),http_req_cnt,gpc0

    #---------------------------------------------------------------------
    # Backend - forwards to actual application
    #---------------------------------------------------------------------
    backend bk_application
        balance roundrobin

        # Health check
        option httpchk GET /health
        http-check expect status 200

        # Backend servers (configured via environment/discovery)
        server app1 {{ include "forms-waf.backend.serviceName" . }}:{{ include "forms-waf.backend.servicePort" . }} check inter 5s fall 3 rise 2

    #---------------------------------------------------------------------
    # Stats frontend
    #---------------------------------------------------------------------
    frontend stats
        bind *:8404
        mode http
        stats enable
        stats uri /stats
        stats refresh 10s
        stats admin if TRUE

        # Prometheus metrics endpoint
        http-request use-service prometheus-exporter if { path /metrics }

    #---------------------------------------------------------------------
    # Health check frontend
    #---------------------------------------------------------------------
    frontend health
        bind *:8405
        mode http
        monitor-uri /health
{{- end }}
