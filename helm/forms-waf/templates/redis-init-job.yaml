{{- if and (or .Values.redis.enabled (not (empty .Values.externalRedis.host))) .Values.redisInit.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "forms-waf.fullname" . }}-redis-init
  labels:
    {{- include "forms-waf.labels" . | nindent 4 }}
    app.kubernetes.io/component: redis-init
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        {{- include "forms-waf.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: redis-init
    spec:
      restartPolicy: OnFailure
      containers:
        - name: redis-init
          image: "{{ .Values.redisInit.image.repository }}:{{ .Values.redisInit.image.tag }}"
          imagePullPolicy: {{ .Values.redisInit.image.pullPolicy }}
          {{- if and (not .Values.redis.enabled) (or .Values.externalRedis.password .Values.externalRedis.existingSecret.name) }}
          env:
            # SECURITY: Use REDISCLI_AUTH instead of -a flag to avoid password exposure in ps output
            - name: REDISCLI_AUTH
              {{- if .Values.externalRedis.existingSecret.name }}
              valueFrom:
                secretKeyRef:
                  name: {{ .Values.externalRedis.existingSecret.name }}
                  key: {{ .Values.externalRedis.existingSecret.key | default "redis-password" }}
              {{- else }}
              value: {{ .Values.externalRedis.password | quote }}
              {{- end }}
          {{- else if .Values.redis.auth.enabled }}
          env:
            # SECURITY: Use REDISCLI_AUTH instead of -a flag to avoid password exposure in ps output
            - name: REDISCLI_AUTH
              valueFrom:
                secretKeyRef:
                  name: {{ .Release.Name }}-redis
                  key: redis-password
          {{- end }}
          {{- if and (not .Values.redis.enabled) .Values.externalRedis.tls.enabled .Values.externalRedis.tls.verify (or .Values.externalRedis.tls.caCert .Values.externalRedis.tls.existingCaSecret.name) }}
          volumeMounts:
            - name: redis-ca-cert
              mountPath: /etc/redis-ca
              readOnly: true
          {{- end }}
          command:
            - /bin/sh
            - -c
            - |
              set -e
              {{- if .Values.redis.enabled }}
              REDIS_HOST="{{ include "forms-waf.redis.host" . }}"
              REDIS_PORT="{{ include "forms-waf.redis.port" . }}"
              REDIS_TLS_OPTS=""
              {{- else }}
              REDIS_HOST="{{ .Values.externalRedis.host }}"
              REDIS_PORT="{{ .Values.externalRedis.port | default 6379 }}"
              {{- if .Values.externalRedis.tls.enabled }}
              {{- if .Values.externalRedis.tls.verify }}
              {{- if or .Values.externalRedis.tls.caCert .Values.externalRedis.tls.existingCaSecret.name }}
              # TLS with certificate verification using provided CA
              REDIS_TLS_OPTS="--tls --cacert /etc/redis-ca/ca.crt"
              {{- else }}
              # TLS with system CA store (works for most cloud providers with public CAs)
              REDIS_TLS_OPTS="--tls"
              {{- end }}
              {{- else }}
              # WARNING: TLS without certificate verification - vulnerable to MITM attacks
              REDIS_TLS_OPTS="--tls --insecure"
              {{- end }}
              {{- else }}
              REDIS_TLS_OPTS=""
              {{- end }}
              {{- end }}

              # Build redis-cli command with optional TLS
              # SECURITY: Authentication is handled via REDISCLI_AUTH env var (set above)
              # which avoids exposing password in process listings
              REDIS_CLI="redis-cli -h $REDIS_HOST -p $REDIS_PORT $REDIS_TLS_OPTS"

              echo "Waiting for Redis to be ready..."
              echo "Connecting to: $REDIS_HOST:$REDIS_PORT (TLS: {{ if and (not .Values.redis.enabled) .Values.externalRedis.tls.enabled }}enabled{{ else }}disabled{{ end }})"
              until $REDIS_CLI ping 2>/dev/null | grep -q PONG; do
                  echo "Waiting for Redis..."
                  sleep 2
              done

              echo "Loading blocked keywords..."
              $REDIS_CLI SADD waf:keywords:blocked \
              {{- range .Values.redisInit.blockedKeywords }}
                "{{ . }}" \
              {{- end }}
                "placeholder-to-avoid-empty"
              $REDIS_CLI SREM waf:keywords:blocked "placeholder-to-avoid-empty"

              echo "Loading flagged keywords..."
              $REDIS_CLI SADD waf:keywords:flagged \
              {{- range .Values.redisInit.flaggedKeywords }}
                "{{ . }}" \
              {{- end }}
                "placeholder-to-avoid-empty"
              $REDIS_CLI SREM waf:keywords:flagged "placeholder-to-avoid-empty"

              echo "Loading thresholds..."
              $REDIS_CLI HSET waf:config:thresholds \
              {{- range $key, $value := .Values.redisInit.thresholds }}
                {{ $key }} {{ $value }} \
              {{- end }}
                placeholder 0
              $REDIS_CLI HDEL waf:config:thresholds placeholder

              {{- if .Values.redisInit.routing.enabled }}
              echo "Loading routing configuration..."
              {{- $haproxyFqdn := printf "%s-haproxy.%s.svc.cluster.local" (include "forms-waf.fullname" .) .Release.Namespace }}
              {{- $haproxyUpstream := .Values.openresty.env.HAPROXY_UPSTREAM | default "" }}
              {{- if not $haproxyUpstream }}
              {{- $haproxyUpstream = printf "%s:%d" $haproxyFqdn (int .Values.haproxy.service.port) }}
              {{- end }}
              {{- $haproxyUpstreamSsl := .Values.openresty.env.HAPROXY_UPSTREAM_SSL | default "" }}
              {{- if not $haproxyUpstreamSsl }}
              {{- $haproxyUpstreamSsl = printf "%s:%d" $haproxyFqdn (int .Values.haproxy.service.httpsPort) }}
              {{- end }}
              $REDIS_CLI HSET waf:config:routing \
                haproxy_upstream "{{ $haproxyUpstream }}" \
                haproxy_upstream_ssl "{{ $haproxyUpstreamSsl }}" \
                upstream_ssl "{{ .Values.openresty.env.UPSTREAM_SSL | default "false" }}" \
                haproxy_timeout "{{ .Values.openresty.env.HAPROXY_TIMEOUT | default "30" }}"
              echo "  HAProxy upstream (HTTP): {{ $haproxyUpstream }}"
              echo "  HAProxy upstream (SSL):  {{ $haproxyUpstreamSsl }}"
              echo "  Use SSL: {{ .Values.openresty.env.UPSTREAM_SSL | default "false" }}"
              {{- end }}

              echo "Loading IP whitelist..."
              $REDIS_CLI SADD waf:whitelist:ips \
              {{- range .Values.redisInit.whitelistedIPs }}
                "{{ . }}" \
              {{- end }}
                "placeholder-to-avoid-empty"
              $REDIS_CLI SREM waf:whitelist:ips "placeholder-to-avoid-empty"

              {{- if .Values.adminUI.enabled }}
              # NOTE: Admin user and RBAC roles are now seeded by OpenResty/Lua on startup
              # See rbac.seed_default_admin() and rbac.seed_roles() in openresty/lua/rbac.lua
              # This ensures roles stay in sync with the codebase and allows secure salt generation
              echo "Admin user and RBAC roles will be seeded by OpenResty on startup (see rbac.lua)"
              {{- end }}

              {{- if .Values.adminUI.auth.providers }}
              echo "Loading auth providers from Helm values..."
              {{- range $provider := .Values.adminUI.auth.providers }}
              {{- if $provider.enabled }}
              # Provider: {{ $provider.id }} ({{ $provider.type }})
              PROVIDER_{{ $provider.id | replace "-" "_" }}_JSON=$(cat <<'PROVIDEREOF'
              {{ $provider | toJson }}
              PROVIDEREOF
              )
              $REDIS_CLI SET "waf:auth:providers:config:{{ $provider.id }}" "$PROVIDER_{{ $provider.id | replace "-" "_" }}_JSON"
              echo "  - Added provider: {{ $provider.id }} ({{ $provider.type }})"
              {{- end }}
              {{- end }}
              {{- end }}

              echo "Loading virtual hosts..."
              {{- range $vhost := .Values.redisInit.vhosts }}
              # Virtual host: {{ $vhost.id }}
              VHOST_{{ $vhost.id | replace "-" "_" }}='{{ $vhost.config | toJson }}'
              $REDIS_CLI SET "waf:vhosts:config:{{ $vhost.id }}" "$VHOST_{{ $vhost.id | replace "-" "_" }}"
              $REDIS_CLI ZADD "waf:vhosts:index" {{ $vhost.priority | default 100 }} "{{ $vhost.id }}"
              {{- range $hostname := $vhost.hostnames }}
              {{- if hasPrefix "*" $hostname }}
              $REDIS_CLI ZADD "waf:vhosts:hosts:wildcard" {{ $vhost.priority | default 100 }} "{{ $hostname }}|{{ $vhost.id }}"
              {{- else }}
              $REDIS_CLI HSET "waf:vhosts:hosts:exact" "{{ $hostname }}" "{{ $vhost.id }}"
              {{- end }}
              {{- end }}
              {{- end }}

              echo "Redis initialization complete!"
              echo "=== Loaded Data Summary ==="
              echo "Blocked keywords: $($REDIS_CLI SCARD waf:keywords:blocked)"
              echo "Flagged keywords: $($REDIS_CLI SCARD waf:keywords:flagged)"
              echo "Whitelisted IPs: $($REDIS_CLI SCARD waf:whitelist:ips)"
              echo "Virtual hosts: $($REDIS_CLI ZCARD waf:vhosts:index)"
              {{- if .Values.redisInit.routing.enabled }}
              echo ""
              echo "=== Routing Configuration ==="
              echo "HAProxy upstream (HTTP): $($REDIS_CLI HGET waf:config:routing haproxy_upstream)"
              echo "HAProxy upstream (SSL):  $($REDIS_CLI HGET waf:config:routing haproxy_upstream_ssl)"
              echo "Use SSL: $($REDIS_CLI HGET waf:config:routing upstream_ssl)"
              echo "Timeout: $($REDIS_CLI HGET waf:config:routing haproxy_timeout)s"
              {{- end }}
              {{- if .Values.adminUI.enabled }}
              echo "Admin users: $($REDIS_CLI KEYS 'waf:admin:users:*' | wc -l)"
              {{- if .Values.adminUI.auth.rbac.enabled }}
              echo "RBAC roles: $($REDIS_CLI KEYS 'waf:auth:roles:config:*' | wc -l)"
              {{- end }}
              {{- if .Values.adminUI.auth.providers }}
              echo "Auth providers: $($REDIS_CLI KEYS 'waf:auth:providers:config:*' | wc -l)"
              {{- end }}
              echo ""
              echo "=== Admin UI Access ==="
              echo "Default credentials: {{ .Values.adminUI.auth.defaultUsername }} / {{ .Values.adminUI.auth.defaultPassword }}"
              echo "WARNING: Change password on first login!"
              {{- if .Values.adminUI.auth.providers }}
              echo ""
              echo "=== SSO Providers Configured ==="
              {{- range $provider := .Values.adminUI.auth.providers }}
              {{- if $provider.enabled }}
              echo "  - {{ $provider.name }} ({{ $provider.type }})"
              {{- end }}
              {{- end }}
              {{- end }}
              {{- end }}
      {{- if and (not .Values.redis.enabled) .Values.externalRedis.tls.enabled .Values.externalRedis.tls.verify (or .Values.externalRedis.tls.caCert .Values.externalRedis.tls.existingCaSecret.name) }}
      volumes:
        - name: redis-ca-cert
          {{- if .Values.externalRedis.tls.existingCaSecret.name }}
          secret:
            secretName: {{ .Values.externalRedis.tls.existingCaSecret.name }}
            items:
              - key: {{ .Values.externalRedis.tls.existingCaSecret.key | default "ca.crt" }}
                path: ca.crt
          {{- else }}
          configMap:
            name: {{ include "forms-waf.fullname" . }}-redis-ca
          {{- end }}
      {{- end }}
{{- end }}
