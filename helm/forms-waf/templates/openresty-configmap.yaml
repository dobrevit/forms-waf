{{- if .Values.openresty.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "forms-waf.fullname" . }}-openresty-config
  labels:
    {{- include "forms-waf.openresty.labels" . | nindent 4 }}
data:
  nginx.conf: |
    # Preserve environment variables for Lua access via os.getenv()
    env REDIS_HOST;
    env REDIS_PORT;
    env REDIS_PASSWORD;
    env REDIS_DB;
    env WAF_ADMIN_AUTH;
    env WAF_SYNC_INTERVAL;
    env HTTP_PROXY;
    env HTTPS_PROXY;
    env NO_PROXY;
    env HAPROXY_UPSTREAM;
    env HAPROXY_UPSTREAM_SSL;
    env UPSTREAM_SSL;
    env WAF_ADMIN_SALT;
    env WAF_ADMIN_PASSWORD;
    env HOSTNAME;
    env WAF_USE_LEADER_ELECTION;

    worker_processes auto;
    error_log /var/log/nginx/error.log warn;
    pid /tmp/nginx.pid;

    events {
        worker_connections 4096;
        use epoll;
        multi_accept on;
    }

    http {
        include /usr/local/openresty/nginx/conf/mime.types;
        default_type application/octet-stream;

        # Hide server version for security
        server_tokens off;
        more_clear_headers 'Server';

        # DNS resolver for Kubernetes service discovery
        # Uses system resolver from /etc/resolv.conf (works with both kube-dns and CoreDNS)
        resolver local=on ipv6=off valid=10s;
        resolver_timeout 5s;

        log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for" '
                        'spam_score=$sent_http_x_spam_score form_hash=$sent_http_x_form_hash';

        log_format json_combined escape=json '{'
            '"time":"$time_iso8601",'
            '"remote_addr":"$remote_addr",'
            '"x_forwarded_for":"$http_x_forwarded_for",'
            '"request_method":"$request_method",'
            '"request_uri":"$request_uri",'
            '"status":$status,'
            '"body_bytes_sent":$body_bytes_sent,'
            '"request_time":$request_time,'
            '"spam_score":"$sent_http_x_spam_score",'
            '"form_hash":"$sent_http_x_form_hash",'
            '"spam_flags":"$sent_http_x_spam_flags",'
            '"blocked":"$sent_http_x_blocked"'
        '}';

        access_log /var/log/nginx/access.log json_combined;

        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 65;
        types_hash_max_size 2048;

        lua_package_path "/etc/nginx/lua/?.lua;;";
        lua_package_cpath "/usr/local/openresty/lualib/?.so;;";

        # Shared dictionaries for caching
        lua_shared_dict keyword_cache 10m;
        lua_shared_dict hash_cache 50m;
        lua_shared_dict config_cache 1m;
        lua_shared_dict ip_whitelist 5m;
        lua_shared_dict ip_whitelist_cidr 1m;
        lua_shared_dict rate_limit 20m;
        lua_shared_dict endpoint_cache 10m;
        lua_shared_dict vhost_cache 10m;
        lua_shared_dict learning_cache 5m;
        lua_shared_dict waf_metrics 10m;
        lua_shared_dict waf_timing 1m;
        lua_shared_dict coordinator_cache 1m;

        # Initialize modules on worker start
        init_worker_by_lua_block {
            local redis_sync = require "redis_sync"
            local rbac = require "rbac"
            local instance_coordinator = require "instance_coordinator"

            -- Initialize Redis with defaults if keys are missing (only on worker 0)
            -- Use timer to defer Redis connection (not allowed directly in init_worker)
            if ngx.worker.id() == 0 then
                ngx.timer.at(0, function()
                    redis_sync.initialize_defaults()
                    -- Seed RBAC roles to Redis (ensures roles are always up-to-date)
                    rbac.seed_roles()
                    -- Seed default admin user if WAF_ADMIN_SALT is set and user doesn't exist
                    rbac.seed_default_admin()
                end)
            end

            -- Start Redis sync timer (all workers)
            redis_sync.start_sync_timer()

            -- Start instance coordinator (handles heartbeat and leader election)
            -- Only worker 0 participates, but call is safe from any worker
            instance_coordinator.start_coordinator_timer()
        }

        # Health check and metrics endpoint
        server {
            listen 8081;
            location /health {
                access_log off;
                return 200 "OK\n";
            }
            location /metrics {
                access_log off;
                content_by_lua_block {
                    local metrics = require "metrics"
                    ngx.say(metrics.get_prometheus())
                }
            }
        }

        # Admin API server (separate port for security)
        server {
            listen 8082;
            server_name _;

            # Separate access log for admin operations (audit trail)
            access_log /var/log/nginx/admin-access.log json_combined;

            # Authentication endpoints (no auth required)
            location /api/auth/ {
                content_by_lua_block {
                    local admin_auth = require "admin_auth"
                    admin_auth.handle_request()
                }
            }

            # Admin API endpoints (auth required)
            location /api/ {
                content_by_lua_block {
                    local admin = require "admin_api"
                    admin.handle_request()
                }
            }

            # Health check for admin port
            location /health {
                access_log off;
                return 200 "OK\n";
            }

            {{- if .Values.adminUI.enabled }}
            # Admin UI - React SPA (catch-all for frontend routes)
            location / {
                # Dynamic resolution - resolve hostname at request time
                set $admin_ui_upstream "{{ include "forms-waf.fullname" . }}-admin-ui.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.adminUI.service.port }}";
                proxy_pass http://$admin_ui_upstream;
                proxy_http_version 1.1;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Connection "";

                # WebSocket support (for HMR in development)
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";
            }
            {{- else }}
            location / {
                default_type application/json;
                return 404 '{"error": "Not found", "hint": "Admin API is available at /api/"}\n';
            }
            {{- end }}
        }

        # Main server (HTTP)
        server {
            listen 8080;
            server_name _;

            # Client body settings for form handling
            client_body_buffer_size 128k;
            client_max_body_size 10m;

            # Health check bypass
            location /health {
                access_log off;
                return 200 "OK\n";
            }

            # CAPTCHA verification endpoint (public - users submit CAPTCHA solutions here)
            location /captcha/verify {
                content_by_lua_block {
                    local captcha_handler = require "captcha_handler"
                    captcha_handler.handle_verification()
                }
            }

            # Main form processing location
            location / {
                # Initialize upstream variable (will be set by Lua based on vhost routing config)
                set $upstream_url "";

                # Process forms with Lua
                access_by_lua_block {
                    local waf = require "waf_handler"
                    waf.process_request()
                }

                # Dynamic proxy based on vhost routing config (set by waf_handler)
                proxy_pass $upstream_url;
                proxy_http_version 1.1;
                proxy_set_header Connection "";
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;

                # Pass computed headers to upstream
                # Note: Headers set by ngx.req.set_header() are forwarded automatically
                # These proxy_set_header lines use $http_* to forward modified request headers
                proxy_set_header X-WAF-Form-Hash $http_x_waf_form_hash;
                proxy_set_header X-WAF-Spam-Score $http_x_waf_spam_score;
                proxy_set_header X-WAF-Spam-Flags $http_x_waf_spam_flags;
                proxy_set_header X-WAF-Client-IP $http_x_waf_client_ip;
                proxy_set_header X-WAF-Submission-Fingerprint $http_x_waf_submission_fingerprint;
                proxy_set_header X-WAF-Fingerprint-Profile $http_x_waf_fingerprint_profile;
                proxy_set_header X-WAF-Fingerprint-Threshold $http_x_waf_fingerprint_threshold;
                proxy_set_header X-WAF-Spam-Threshold $http_x_waf_spam_threshold;
                proxy_set_header X-WAF-Hash-Rate-Threshold $http_x_waf_hash_rate_threshold;
                proxy_set_header X-WAF-IP-Spam-Threshold $http_x_waf_ip_spam_threshold;
                proxy_set_header X-WAF-Debug $http_x_waf_debug;
                proxy_set_header X-WAF-Mode $http_x_waf_mode;
                proxy_set_header X-WAF-Rate-Limit $http_x_waf_rate_limit;
                proxy_set_header X-WAF-Rate-Limit-Value $http_x_waf_rate_limit_value;
                proxy_set_header X-WAF-Endpoint $http_x_waf_endpoint;
                proxy_set_header X-WAF-Vhost $http_x_waf_vhost;
            }
        }

        # Main server (HTTPS)
        # Self-signed certificate is generated at container startup
        # Mount your own certificate to /etc/nginx/ssl/ to override
        server {
            listen 8443 ssl;
            server_name _;

            # SSL configuration
            ssl_certificate /etc/nginx/ssl/server.crt;
            ssl_certificate_key /etc/nginx/ssl/server.key;

            # Modern SSL settings
            ssl_protocols TLSv1.2 TLSv1.3;
            ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
            ssl_prefer_server_ciphers off;
            ssl_session_cache shared:SSL:10m;
            ssl_session_timeout 1d;
            ssl_session_tickets off;

            # Client body settings for form handling
            client_body_buffer_size 128k;
            client_max_body_size 10m;

            # Health check bypass
            location /health {
                access_log off;
                return 200 "OK\n";
            }

            # CAPTCHA verification endpoint (public - users submit CAPTCHA solutions here)
            location /captcha/verify {
                content_by_lua_block {
                    local captcha_handler = require "captcha_handler"
                    captcha_handler.handle_verification()
                }
            }

            # Main form processing location
            location / {
                # Initialize upstream variable (will be set by Lua based on vhost routing config)
                set $upstream_url "";

                # Process forms with Lua
                access_by_lua_block {
                    local waf = require "waf_handler"
                    waf.process_request()
                }

                # Dynamic proxy based on vhost routing config (set by waf_handler)
                proxy_pass $upstream_url;
                proxy_http_version 1.1;
                proxy_set_header Connection "";
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto https;

                # Pass computed headers to upstream
                proxy_set_header X-WAF-Form-Hash $http_x_waf_form_hash;
                proxy_set_header X-WAF-Spam-Score $http_x_waf_spam_score;
                proxy_set_header X-WAF-Spam-Flags $http_x_waf_spam_flags;
                proxy_set_header X-WAF-Client-IP $http_x_waf_client_ip;
                proxy_set_header X-WAF-Submission-Fingerprint $http_x_waf_submission_fingerprint;
                proxy_set_header X-WAF-Fingerprint-Profile $http_x_waf_fingerprint_profile;
                proxy_set_header X-WAF-Fingerprint-Threshold $http_x_waf_fingerprint_threshold;
                proxy_set_header X-WAF-Spam-Threshold $http_x_waf_spam_threshold;
                proxy_set_header X-WAF-Hash-Rate-Threshold $http_x_waf_hash_rate_threshold;
                proxy_set_header X-WAF-IP-Spam-Threshold $http_x_waf_ip_spam_threshold;
                proxy_set_header X-WAF-Debug $http_x_waf_debug;
                proxy_set_header X-WAF-Mode $http_x_waf_mode;
                proxy_set_header X-WAF-Rate-Limit $http_x_waf_rate_limit;
                proxy_set_header X-WAF-Rate-Limit-Value $http_x_waf_rate_limit_value;
                proxy_set_header X-WAF-Endpoint $http_x_waf_endpoint;
                proxy_set_header X-WAF-Vhost $http_x_waf_vhost;
            }
        }
    }
{{- end }}
